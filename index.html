<!DOCTYPE html>
<!-- Объявление типа документа: сообщаем браузеру, что это современный стандарт HTML5 -->
<html lang="ru">
<head>
    <!-- Установка кодировки UTF-8 для корректного отображения русского языка -->
    <meta charset="UTF-8">
    
    <!-- Настройки области просмотра: 
         width=device-width — ширина равна ширине экрана телефона.
         initial-scale=1.0 — начальный масштаб 100%.
         maximum-scale=1.0 и user-scalable=no — запрещаем пользователю приближать/отдалять страницу пальцами (важно для игр). -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Название вкладки в браузере -->
    <title>ZVX and AI PING PONG v1.2.7</title>

    <style>
        /* Глобальные настройки стилей */
        :root { 
            --neon: #0f0;  /* Создаем переменную для цвета (ярко-зеленый неон) */
            --bg: #050505; /* Создаем переменную для цвета фона (черный графит) */
        }

        /* Настройка всего тела страницы */
        body { 
            background: var(--bg);        /* Устанавливаем черный фон из переменной */
            color: var(--neon);           /* Устанавливаем основной цвет текста */
            font-family: 'Consolas', monospace; /* Шрифт имитирует код или старые компьютеры */
            display: flex;                /* Включаем гибкий контейнер для центровки */
            flex-direction: column;       /* Располагаем элементы (заголовок, канвас) вертикально друг под другом */
            align-items: center;          /* Центруем все элементы по горизонтали */
            justify-content: center;      /* Центруем все элементы по вертикали */
            height: 100vh;                /* Высота страницы на весь экран */
            margin: 0;                    /* Убираем стандартные отступы браузера по краям */
            overflow: hidden;             /* Запрещаем прокрутку страницы (скроллбары) */
            user-select: none;            /* Запрещаем выделять текст синим цветом при долгом нажатии */
            touch-action: none;           /* Отключаем жесты браузера (скролл пальцем, обновление страницы потяжкой вниз) */
        }

        /* Стиль главного заголовка */
        #header {
            width: 800px;                 /* Ширина заголовка (как у игрового поля) */
            max-width: 95%;               /* На узких телефонах ширина не более 95% экрана */
            text-align: center;           /* Текст внутри рамки по центру */
            font-size: clamp(16px, 5vw, 32px); /* Размер шрифта: минимум 16px, на больших экранах до 32px */
            font-weight: 900;             /* Очень жирный шрифт */
            letter-spacing: 5px;          /* Расстояние между буквами для красоты */
            padding: 10px 0;              /* Внутренние отступы сверху и снизу текста */
            margin-bottom: 10px;          /* Отступ снизу до игрового поля */
            border: 3px solid var(--neon); /* Рамка вокруг заголовка */
            text-shadow: 0 0 10px var(--neon); /* Свечение текста (неоновый эффект) */
            animation: flicker 3s infinite;    /* Привязываем анимацию "flicker", длительность 3 сек, бесконечно */
            transition: all 0.4s ease;    /* Плавный переход при смене цвета (например, в режиме Argus) */
        }

        /* Логика анимации мерцания (имитация старой лампы) */
        @keyframes flicker { 
            /* На определенных процентах времени анимации прозрачность полная (1) или частичная (0.7) */
            0%, 18%, 22%, 25%, 53%, 57%, 100% { opacity: 1; } 
            20%, 24%, 55% { opacity: 0.7; } 
        }
        
        /* Контейнер, в котором лежит холст игры */
        #game-container { 
            position: relative;           /* Позволяет позиционировать элементы внутри (если понадобится) */
            max-width: 95%;               /* Ширина контейнера подстраивается под экран телефона */
        }

        /* Стиль самого игрового поля (Canvas) */
        canvas { 
            border: 2px solid var(--neon); /* Рамка вокруг игрового поля */
            background: #000;             /* Внутри поля всегда чисто черный цвет */
            display: block;               /* Убираем лишние зазоры снизу канваса */
            max-width: 100%;              /* Поле автоматически сужается под размер экрана */
            max-height: 500px;            /* Ограничение высоты, чтобы не вылезало за экран */
            cursor: none;                 /* Скрываем курсор мыши внутри поля игры */
            transition: border-color 0.4s ease; /* Плавная смена цвета рамки */
        }
        
        /* Панель с цифрами счета и рекордов (HUD) */
        .hud { 
            width: 800px;                 /* Ширина панели совпадает с полем */
            max-width: 95%;               /* Адаптивность для мобильных */
            display: flex;                /* Располагаем счет слева и рекорд справа */
            justify-content: space-between; /* Максимально раздвигаем элементы по краям */
            margin-bottom: 10px;          /* Отступ снизу */
            font-size: clamp(12px, 4vw, 22px); /* Размер шрифта подстраивается под экран */
            font-weight: bold;            /* Жирный шрифт для цифр */
        }
        
        /* Контейнер полоски активного бонуса */
        #b-bar { 
            width: 800px;                 /* Базовая ширина полоски (такая же, как у игрового поля на ПК) */
            max-width: 95%;               /* На маленьких экранах полоска не выйдет за границы и будет занимать 95% ширины */
            height: 4px;                  /* Высота полоски (тонкая линия) */
            background: #111;             /* Цвет подложки (темно-серый) */
            margin-top: 8px;              /* Отступ сверху от канваса */
            overflow: hidden;             /* Все, что выходит за границы линии, обрезается */
            border-radius: 2px;           /* Слегка скругленные края */
        }

        /* Сама заполняющаяся часть полоски бонуса */
        #b-fill { 
            width: 0%;                    /* По умолчанию 0% (бонусов нет) */
            height: 100%;                 /* Заполняет всю высоту родителя (4px) */
            transition: width 0.1s linear; /* Плавное уменьшение длины полоски */
            background: #0f0;             /* Цвет заполнения (зеленый) */
        }
        
        /* Блок управления для мобильных (слайдер) */
        #slider-container { 
            width: 800px;                 /* Устанавливаем ширину зоны управления в 800 пикселей (стандарт для проекта) */
            max-width: 95%;               /* Ограничиваем ширину до 95% от экрана устройства, чтобы ползунок не упирался в края телефона */
            margin-top: 40px;             /* Большой отступ сверху, чтобы не нажимать на игру пальцем */
            display: none;                /* Скрыто по умолчанию (для ПК) */
        }

        /* Если JavaScript обнаружит телефон, он добавит тегу body класс .touch-device */
        .touch-device #slider-container { 
            display: block;               /* Показываем слайдер только на телефонах */
        }

        /* Дизайн самого ползунка (линии) */
        #paddleControl { 
            -webkit-appearance: none;     /* Отключаем стандартный скучный вид браузера */
            width: 100%;                  /* На всю ширину контейнера */
            height: 25px;                 /* Толщина линии слайдера */
            background: #000;             /* Черный фон линии */
            border: 2px solid var(--neon); /* Неоновая обводка линии */
            border-radius: 15px;          /* Закругление краев линии */
            outline: none;                /* Убираем синюю рамку при нажатии */
        }

        /* Дизайн "ручки" ползунка (то, что тянем пальцем) */
        #paddleControl::-webkit-slider-thumb { 
            -webkit-appearance: none;     /* Отключаем стандартную круглую кнопку */
            width: 65px;                  /* Большая ширина для удобства попадания пальцем */
            height: 65px;                 /* Большая высота кнопки */
            background: #000;             /* Черный фон кнопки */
            border: 3px solid var(--neon); /* Толстая неоновая обводка кнопки */
            border-radius: 10px;          /* Форма кнопки — квадрат со скруглением */
            box-shadow: 0 0 15px var(--neon); /* Свечение вокруг кнопки */
            cursor: pointer;              /* Указатель мыши (для тестов на ПК) */
        }
    </style>
</head>

<body>
    <div id="header">ZVX and AI PING PONG v1.2.7</div>
    
	     <!-- Основной контейнер верхней панели (Heads-Up Display) -->
    <div class="hud">
        
        <!-- ЛЕВЫЙ БЛОК: Текущий счет игрока -->
        <div>
            <!-- Текст "SCORE" и числовое значение (по умолчанию 0) -->
            SCORE: <span id="score">0</span> 
            
            <!-- Дополнительная панель для секретного режима Argus (изначально скрыта) -->
            <!-- style="display:none;" — делает элемент невидимым до активации режима -->
            <span id="argus-label" style="display:none; color:#a0f;">
                | ARGUS: <span id="argus-score">0</span>
            </span>
        </div>

        <!-- ЦЕНТРАЛЬНЫЙ БЛОК: Текстовые сообщения (например, "WARNING" или "SLOW ACTIVE") -->
        <!-- id="msg" — через этот идентификатор JavaScript будет менять текст внутри -->
        <div id="msg" style="color:#fff; font-size: 14px; text-shadow: 0 0 5px #fff; text-align: center;"></div>

        <!-- ПРАВЫЙ БЛОК: Лучший результат (рекорд) -->
        <div>
            <!-- Основной рекорд в обычном режиме -->
            BEST: <span id="best">0</span> 
            
            <!-- Рекорд в режиме Argus (также скрыт до активации) -->
            <!-- (A: 0) — сокращение для Argus Best Score -->
            <span id="argus-best-label" style="display:none; color:#a0f;">
                (A: <span id="argus-best">0</span>)
            </span>
        </div>
        
    </div> <!-- Конец панели HUD -->

    <div id="game-container">
        <canvas id="game" width="800" height="500"></canvas>
    </div>

    <div id="b-bar"><div id="b-fill"></div></div>
    
    <div id="slider-container">
        <input type="range" id="paddleControl" min="0" max="100" value="50">
    </div>

    <script>
		// ------------------------------------------------------------
		// СЕКЦИЯ: ПОИСК ЭЛЕМЕНТОВ И ПОДГОТОВКА ХОЛСТА
		// ------------------------------------------------------------

		/* Ищем само игровое поле (Canvas) в HTML по его ID 'game' */
		const canvas = document.getElementById('game');

		/* Создаем "контекст рисования" (ctx). 
       '2d' означает, что мы будем рисовать плоские фигуры: линии, круги и квадраты */
		const ctx = canvas.getContext('2d');

		/* Связываем переменную headerEl с заголовком игры, чтобы менять его текст или цвет */
		const headerEl = document.getElementById('header');

		/* Связываем переменную scoreEl с числом текущих очков в панели HUD */
		const scoreEl = document.getElementById('score');
	
		/* Связываем переменную bestEl с числом лучшего рекорда */
		const bestEl = document.getElementById('best');

		/* Связываем bFill с полоской бонусов, чтобы менять её длину (ширину) в процентах */
		const bFill = document.getElementById('b-fill');

		/* Связываем msgEl с пустым блоком сообщений, чтобы выводить туда текст "WARNING" и т.д. */
		const msgEl = document.getElementById('msg');

		/* Связываем slider с ползунком управления, чтобы считывать движение пальца игрока */
		const slider = document.getElementById('paddleControl');

        
        // Глобальные состояния
        let gameActive = false;
        let isGameOver = false;
        let isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if (isTouch) document.body.classList.add('touch-device');
				
		// ------------------------------------------------------------
		// СЕКЦИЯ: ЗВУКОВАЯ СИСТЕМА (Web Audio API)
		// ------------------------------------------------------------

		/* Создаем ссылку на аудио-движок браузера (поддержка для Chrome и Safari) */
		const AudioContext = window.AudioContext || window.webkitAudioContext;

		/* Переменная для хранения самого аудио-контекста (изначально пустая) */
		let audioCtx = null;

		/* Объект SFX (Sound Effects) — содержит все звуковые функции игры */
		const SFX = {
    
		/* Функция инициализации: "будит" звук после первого нажатия пользователя */
		init() { 
        /* Если контекст еще не создан — создаем его */
        if (!audioCtx) audioCtx = new AudioContext(); 
        /* Если звук "завис" (особенность браузеров) — возобновляем его работу */
        if (audioCtx.state === 'suspended') audioCtx.resume(); 
    },

		/* Универсальный генератор звука: частота, тип волны, длительность, громкость */
		play(freq, type, duration, vol = 0.1) {
        this.init(); // Проверяем, готов ли звук
        
        const osc = audioCtx.createOscillator(); // Создаем "осциллятор" (генератор волны)
        const gain = audioCtx.createGain();       // Создаем "регулятор громкости"
        
        osc.type = type; // Устанавливаем форму волны: 'sine' (мягкая), 'square' (резкая) и т.д.
        
        /* Устанавливаем частоту звука (высокий или низкий тон) */
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        
        /* Устанавливаем начальную громкость */
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        
        /* Плавное затухание звука до почти нуля (0.0001), чтобы не было резких щелчков */
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
        
        /* Соединяем генератор с регулятором, а регулятор — с динамиками */
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.start(); // Включаем звук
        osc.stop(audioCtx.currentTime + duration); // Выключаем звук по истечении времени
    },

		/* Конкретные звуковые эффекты (наборы настроек для функции play) */
    
		/* Звук удара об стены (низкий, резкий квадратный сигнал) */
		hit() { this.play(150, 'square', 0.1); },
    
		/* Звук удара об ракетку (чистый тон "ля" 440Гц, мягкая волна) */
		paddle() { this.play(440, 'sine', 0.15); },
    
		/* Звук подбора бонуса (высокий, "кристальный" звук) */
		powerup() { this.play(880, 'triangle', 0.4); },
    
		/* Звук получения урона (очень низкий, жужжащий пилообразный звук) */
		damage() { this.play(60, 'sawtooth', 0.3, 0.2); },
    
		/* Звук отскока от треугольника (короткий и мягкий) */
		triangle() { this.play(200, 'sine', 0.1, 0.2); }
	};

		// ------------------------------------------------------------
		// СЕКЦИЯ: СИСТЕМА ВИБРАЦИИ 
		// ------------------------------------------------------------

		/* Функция для тактильной отдачи на мобильных устройствах */
		const vibrate = (ms) => {
		/* Если переменная isTouch будет true (определим позже) и браузер умеет вибрировать */
		if (isTouch && navigator.vibrate) {
        navigator.vibrate(ms); /* Вибрируем указанное количество миллисекунд */
		}
	};


        // Хранение рекордов
        let score = 0;
        let argusScore = 0;
        let best = localStorage.getItem('rv_best') || 0;
        let argusBest = localStorage.getItem('rv_argus_best') || 0;
        
        bestEl.innerText = best;
        document.getElementById('argus-best').innerText = argusBest;

        // Игровые объекты и параметры
        let pY = 200; // Позиция ракетки
        let pH = 90;  // Высота ракетки
        let particles = [];
        let powerups = [];
        let enemies = [];
        let balls = [{x: 400, y: 250, dx: 5, dy: 5}]; 
        let obstacle = null;
        let lastSpawnScore = -1;
        let bTimer = 0; // Таймер активного бонуса
        let gameSpeedMult = 1.0;
        let scannerY = 0; // Для визуального эффекта препятствия
        let trajOn = false; // Режим ARGUS
		/* Устанавливаем максимально допустимую скорость мяча (пикселей за кадр).
		Значение 22 — это предел. Даже если бонусы или удары пытаются ускорить мяч сильнее,
		он не превысит этот порог, чтобы игра оставалась честной и управляемой. */
        const MAX_SPEED = 22; // максимальная скорость мяча

        // Секретный режим Argus (активируется через консоль: Argus2D)
        Object.defineProperty(window, 'Argus2D', {
            get: function() {
                trajOn = !trajOn;
                const color = trajOn ? "#a0f" : "#0f0";
                pH = trajOn ? 250 : 90;
                
                headerEl.innerText = trajOn ? "Argus2D PING PONG" : "ZVX and AI PING PONG v1.2.4";
                headerEl.style.color = color;
                headerEl.style.borderColor = color;
                headerEl.style.textShadow = `0 0 15px ${color}`;
                canvas.style.borderColor = color;
                document.documentElement.style.setProperty('--neon', color);
                
                document.getElementById('argus-label').style.display = trajOn ? "inline" : "none";
                document.getElementById('argus-best-label').style.display = trajOn ? "inline" : "none";
                
                if (trajOn) SFX.powerup();
                msgEl.innerText = trajOn ? "ARGUS SYSTEM: OVERDRIVE" : "ARGUS SYSTEM: STANDBY";
                msgEl.style.color = color;
                
                return "Argus2D Status: " + trajOn;
            }
        });

        // Запуск игры
        function tryStart() { 
            if (!gameActive || isGameOver) { 
                SFX.init(); 
				vibrate(1); // <--- ЭТО. Пустой "пинок" для браузера, чтобы разрешить вибрацию
                resetGame(); 
                gameActive = true; 
                isGameOver = false; 
            } 
        }
        
			/* ------------------------------------------------------------
			СЕКЦИЯ: СЛУШАТЕЛИ СОБЫТИЙ (УПРАВЛЕНИЕ)
			------------------------------------------------------------ */

			/* Отслеживаем нажатие кнопки мыши на игровом поле.
			Если нажать на Canvas, запустится функция tryStart (начало игры) */
			canvas.addEventListener('mousedown', tryStart);

			/* Отслеживаем прикосновение пальца к игровому полю (для телефонов) */
			canvas.addEventListener('touchstart', (e) => { 
			/* e.preventDefault() — отменяет стандартные действия браузера, 
			например, чтобы страница не дергалась при нажатии на игру */
			e.preventDefault(); 
			/* Запускаем игру при касании */
			tryStart(); 
		});

			/* Отслеживаем касание пальцем ползунка управления (слайдера) */
			slider.addEventListener('touchstart', () => { 
			/* Если игра еще не активна или уже закончена (Game Over) */
			if (!gameActive || isGameOver) {
				/* ЗАПУСКАЕМ ИГРУ: теперь при первом же касании ползунка игра начнется автоматически */
				tryStart(); 
			}
			/* {passive: true} — подсказка браузеру, что мы не будем отменять прокрутку здесь, 
			это делает работу слайдера более плавной */
		}, {passive: true});

			/* Отслеживаем само перемещение ползунка (когда палец двигает его влево-вправо) */
			slider.addEventListener('input', () => { 
			/* Если игра сейчас идет (не режим Game Over) */
			if (!isGameOver) {
			/* ВЫЧИСЛЯЕМ ПОЗИЦИЮ РАКЕТКИ:
			1. Берем значение слайдера (от 0 до 100).
			2. Делим на 100, чтобы получить число от 0.0 до 1.0.
			3. Умножаем на (высоту поля МИНУС высота ракетки).
			Результат записываем в pY — это вертикальная координата ракетки на экране */
			pY = (slider.value / 100) * (canvas.height - pH);
		}
		});

        
        window.addEventListener('mousemove', (e) => {
            if (isGameOver || isTouch) return;
            const r = canvas.getBoundingClientRect();
            // Расчет позиции ракетки относительно курсора
            pY = Math.max(0, Math.min(canvas.height - pH, (e.clientY - r.top) * (canvas.height / r.height) - pH / 2));
            slider.value = (pY / (canvas.height - pH)) * 100;
        });

        // Математическая проверка вхождения точки в треугольное препятствие
        function isPointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
            let area = Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2);
            let a1 = Math.abs((px*(y1-y2) + x1*(y2-py) + x2*(py-y1))/2);
            let a2 = Math.abs((px*(y2-y3) + x2*(y3-py) + x3*(py-y2))/2);
            let a3 = Math.abs((px*(y3-y1) + x3*(y1-py) + x1*(py-y3))/2);
            return Math.abs(area - (a1 + a2 + a3)) < 1.0;
        }

        // Сброс интерфейса к дефолту
        function forceResetUI() { 
            bTimer = 0; 
            bFill.style.width = "0%"; 
            msgEl.innerText = ""; 
            pH = trajOn ? 250 : 90; 
            gameSpeedMult = 1.0; 
            slider.value = 50; 
        }

        // Эффект тряски экрана
        function shake(intensity = 15) { 
            canvas.style.transform = `translate(${(Math.random()-0.5)*intensity}px, ${(Math.random()-0.5)*intensity}px)`; 
            setTimeout(() => canvas.style.transform = 'translate(0,0)', 50); 
        }

        // Создание взрыва частиц
        function createParticles(x, y, color, count=12) { 
            for(let i=0; i<count; i++) {
                particles.push({ 
                    x, y, 
                    dx: (Math.random()-0.5)*10, 
                    dy: (Math.random()-0.5)*10, 
                    life: 1, 
                    color 
                }); 
            }
        }
        
        // Полный сброс параметров перед новой игрой
        function resetGame() { 
            score = 0; 
            argusScore = 0; 
            scoreEl.innerText = 0; 
            document.getElementById('argus-score').innerText = 0;
            lastSpawnScore = -1; 
            balls = [{x: 400, y: 250, dx: 5, dy: 5}]; 
            forceResetUI(); 
            powerups = []; 
            enemies = []; 
            particles = []; 
            obstacle = null; 
        }

        // ГЛАВНЫЙ ИГРОВОЙ ЦИКЛ
        function update() {
            // Экран меню / Game Over
            if (!gameActive || isGameOver) {
                ctx.fillStyle = "#000"; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const btnColor = trajOn ? "#a0f" : "#0f0";
                ctx.strokeStyle = btnColor; 
                ctx.lineWidth = 3; 
                ctx.strokeRect(300, 220, 200, 60);
                
                ctx.fillStyle = btnColor; 
                ctx.font = "bold 24px Consolas"; 
                ctx.textAlign = "center";
                
                if (isGameOver) {
                    ctx.fillStyle = "white"; 
                    ctx.font = "bold 40px Consolas"; 
                    ctx.fillText("GAME OVER", 400, 150);
                    ctx.font = "20px Consolas"; 
                    ctx.fillText("NORMAL SCORE: " + score, 400, 190);
                    if(argusScore > 0) { 
                        ctx.fillStyle = "#a0f"; 
                        ctx.fillText("ARGUS SCORE: " + argusScore, 400, 215); 
                    }
                    ctx.fillStyle = btnColor; 
                    ctx.fillText("RESTART", 400, 258);
                } else { 
                    ctx.fillText("START", 400, 258); 
                }
                requestAnimationFrame(update); 
                return;
            }

            // Отрисовка фона (с легким шлейфом)
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Обработка частиц
            particles.forEach((p, i) => { 
                p.x += p.dx; 
                p.y += p.dy; 
                p.life -= 0.02; 
                ctx.fillStyle = p.color; 
                ctx.globalAlpha = p.life; 
                ctx.fillRect(p.x, p.y, 3, 3); 
                if(p.life <= 0) particles.splice(i, 1); 
            });
            ctx.globalAlpha = 1;

            // Логика препятствия-треугольника
            if (obstacle) {
                obstacle.timer--; 
                scannerY = (scannerY + 5) % canvas.height;
                
                // Визуальная линия сканера
                ctx.strokeStyle = "rgba(0, 255, 255, 0.1)"; 
                ctx.lineWidth = 1; 
                ctx.beginPath(); 
                ctx.moveTo(0, scannerY); 
                ctx.lineTo(canvas.width, scannerY); 
                ctx.stroke();

                // Мерцание перед исчезновением
                let op = (obstacle.timer < 120 && Math.floor(obstacle.timer / 10) % 2 === 0) ? 0.2 : 1;
                let x1 = obstacle.x, y1 = obstacle.y - 60, 
                    x2 = obstacle.x + 60, y2 = obstacle.y + 60, 
                    x3 = obstacle.x - 60, y3 = obstacle.y + 60;
                
                ctx.strokeStyle = `rgba(255, 255, 0, ${op})`; 
                ctx.lineWidth = 4;
                ctx.shadowBlur = (op > 0.5) ? 15 : 0; 
                ctx.shadowColor = "#ff0";
                
                ctx.beginPath(); 
                ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); 
                ctx.closePath(); ctx.stroke(); 
                ctx.shadowBlur = 0;

                if (obstacle.timer <= 0) { 
                    obstacle = null; 
                    if(!trajOn) msgEl.innerText = ""; 
                }
            }

            // Обработка врагов (красные квадраты)
            enemies.forEach((e, i) => {
                e.x += e.dx * gameSpeedMult; 
                e.y += e.dy * gameSpeedMult; 
                if(e.y < 10 || e.y > 490) e.dy *= -1;
                
                ctx.fillStyle = "#f04"; 
                ctx.fillRect(e.x-8, e.y-8, 16, 16);

                // Столкновение врага с ракеткой игрока
                if (e.x < 40 && e.x > 15 && e.y > pY && e.y < pY + pH) { 
                    pH = Math.max(30, pH - 15); // Уменьшаем ракетку
                    shake(25); 
                    SFX.damage(); 
                    createParticles(e.x, e.y, "#f04", 15); 
                    enemies.splice(i, 1); 
                } else if (e.x < -20) {
                    enemies.splice(i, 1);
                }
            });

            // Обработка бонусов (Power-ups)
            powerups.forEach((p, i) => {
                p.x += p.dx * gameSpeedMult; 
                p.y += p.dy * gameSpeedMult; 
                if(p.y < 10 || p.y > 490) p.dy *= -1;
                
                ctx.fillStyle = p.c; 
                ctx.fillRect(p.x, p.y, 18, 18);

                // Сбор бонуса ракеткой
                if (p.x < 40 && p.x > 15 && p.y > pY && p.y < pY + pH) {
                    SFX.powerup(); 
                    if (p.n === 'WIDE') pH = 180; 
                    if (p.n === 'SLOW') gameSpeedMult = 0.4;
                    if (p.n === 'MULTI') {
                        balls.push({x: 45, y: pY + pH/2, dx: 6, dy: (Math.random()-0.5)*10});
                    }
                    
                    bTimer = 500; 
                    msgEl.innerText = p.n + " ACTIVE"; 
                    msgEl.style.color = p.c; 
                    bFill.style.backgroundColor = p.c; 
                    createParticles(p.x, p.y, p.c, 15); 
                    powerups.splice(i, 1);
                } else if (p.x < -20) {
                    powerups.splice(i, 1);
                }
            });

            // Таймер прогресс-бара бонуса
            if (bTimer > 0) { 
                bTimer--; 
                bFill.style.width = (bTimer / 5) + "%"; 
                if (bTimer <= 0) forceResetUI(); 
            }

            // ЛОГИКА МЯЧЕЙ
            balls.forEach((b, i) => {
                // Отрисовка траектории (только в режиме Argus)
                if (trajOn) {
                    let tx = b.x, ty = b.y, tdx = b.dx, tdy = b.dy;
                    ctx.beginPath(); 
                    ctx.moveTo(tx, ty);
                    ctx.strokeStyle = `rgba(160, 0, 255, 0.4)`;
                    for (let j = 0; j < 250; j++) {
                        tx += tdx * gameSpeedMult; 
                        ty += tdy * gameSpeedMult;
                        if (ty < 10) { ty = 10; tdy = Math.abs(tdy); } 
                        else if (ty > 490) { ty = 490; tdy = -Math.abs(tdy); }
                        if (tx > 790) { tx = 790; tdx = -Math.abs(tdx); }
                        
                        if (obstacle && isPointInTriangle(tx, ty, obstacle.x, obstacle.y-60, obstacle.x+60, obstacle.y+60, obstacle.x-60, obstacle.y+60)) {
                            tdx = Math.abs(tdx) * 1.05; 
                            tdy = (ty < obstacle.y) ? -Math.abs(tdy) : Math.abs(tdy); 
                            tx += tdx;
                        }
                        if (j % 5 === 0) ctx.lineTo(tx, ty);
                        if (tx < 40 || tx > 800) break;
                    }
                    ctx.stroke();
                }

					// ПРОВЕРКА СТОЛКНОВЕНИЯ С РАКЕТКОЙ
					/* 1. Вычисляем, где будет мяч на следующем кадре */
					let nextX = b.x + b.dx * gameSpeedMult;

					/* 2. Если мяч летит влево (dx < 0) и пересекает линию ракетки (X = 40) */
					if (b.dx < 0 && b.x >= 40 && nextX <= 40) {
				
					/* 3. Математически точно находим точку Y, в которой мяч пересечет линию X = 40 */
					let intersectY = b.y + (b.dy * (40 - b.x) / b.dx);

                        /* 4. ПРОВЕРКА ПОПАДАНИЯ ПО РАКЕТКЕ (С НЕВИДИМЫМ РАСШИРЕНИЕМ)
						Вместо: intersectY > pY && intersectY < pY + pH
						Пишем:  intersectY > (pY - 15) && intersectY < (pY + pH + 15)
						Это добавляет по 15 пикселей "магнитного" поля сверху и снизу */
						if (intersectY > (pY - 15) && intersectY < (pY + pH + 15)) {
						
						/* ВКЛЮЧАЕМ ВИБРАЦИЮ (40 мс — четкий удар) */
						vibrate(40); 
					
                        // Ускорение мяча
						/* Ускоряем мяч на 8% после успешного удара, но не выше лимита MAX_SPEED */
                        b.dx = Math.min(Math.abs(b.dx) * 1.08, MAX_SPEED);
						/* Слегка ускоряем вертикальный отскок для динамики */
                        b.dy = Math.max(Math.min(b.dy * 1.08, MAX_SPEED), -MAX_SPEED);
						/* Выталкиваем мяч чуть правее ракетки, чтобы он не застрял в ней */
                        b.x = 42; 
                        
                        // Начисление очков
                        if (trajOn) {
                            argusScore++;
                            document.getElementById('argus-score').innerText = argusScore;
                        } else {
                            score++;
                            scoreEl.innerText = score;
                        }
						
						                        // ПРОВЕРКА ПОЯВЛЕНИЯ ПРЕПЯТСТВИЯ
                        // Вычисляем текущий активный счет в зависимости от режима
                        const currentActiveScore = trajOn ? argusScore : score;

                        // Если набрано кратно 10 очков и препятствие еще не создано для этого значения счета
                        if (currentActiveScore > 0 && currentActiveScore % 10 === 0 && lastSpawnScore !== currentActiveScore) { 
                            lastSpawnScore = currentActiveScore; 
                            // Создаем объект препятствия: координаты X (в правой части), Y и время жизни (кадры)
                            obstacle = { 
                                x: 450 + Math.random() * 200, 
                                y: 150 + Math.random() * 200, 
                                timer: 540 
                            }; 
                            
                            // Визуальное оповещение о появлении препятствия
                            msgEl.innerText = "WARNING: OBSTACLE DETECTED";
                            msgEl.style.color = "#ff0";
                        }

                        
                        shake(15); 
                        SFX.paddle();
                        createParticles(b.x, b.y, trajOn ? '#a0f' : '#0f0', 15);

                        // Шанс выпадения бонуса (30%)
                        if (Math.random() > 0.7) { 
                            const t = [
                                {n:'WIDE',  c:'#0f0'},
                                {n:'SLOW',  c:'#0ff'},
                                {n:'MULTI', c:'#ff0'}
                            ][Math.floor(Math.random()*3)]; 
                            powerups.push({x:780, y:Math.random()*400+50, dx:-3, dy:(Math.random()>0.5?2:-2), ...t}); 
                        }

                        // Шанс появления врага (20%)
                        if (Math.random() > 0.8) {
                            enemies.push({x:800, y:Math.random()*460+20, dx:-(4+Math.random()*3), dy:(Math.random()>0.5?2:-2)});
                        }

                        // Спавн препятствия каждые 10 очков
                        if (score > 0 && score % 10 === 0 && lastSpawnScore !== score) { 
                            lastSpawnScore = score; 
                            obstacle = { x: 450 + Math.random() * 200, y: 150 + Math.random() * 200, timer: 540 }; 
                        }
                    }
                }

                // Движение мяча и физика отскоков
                b.x += b.dx * gameSpeedMult; 
                b.y += b.dy * gameSpeedMult;
                
                // Цвет мяча зависит от скорости (в обычном режиме)
                ctx.fillStyle = trajOn ? "#a0f" : `hsl(${Math.max(0, 120 - (Math.sqrt(b.dx**2 + b.dy**2) - 7) * 12)}, 100%, 50%)`;
                ctx.beginPath(); 
                ctx.arc(b.x, b.y, 9, 0, Math.PI * 2); 
                ctx.fill();

                // Отскок от верхней/нижней границ
                if(b.y < 10 || b.y > 490) { 
                    b.dy *= -1; 
                    SFX.hit(); 
                }
                // Отскок от правой стены
                if(b.x > 790) { 
                    b.dx *= -1; 
                    b.x = 790; 
                    shake(10); 
                    SFX.hit(); 
                }

                // Отскок от треугольного препятствия
                if (obstacle && isPointInTriangle(b.x, b.y, obstacle.x, obstacle.y-60, obstacle.x+60, obstacle.y+60, obstacle.x-60, obstacle.y+60)) {
                    b.dx = Math.min(Math.abs(b.dx) * 1.05, MAX_SPEED);
                    b.dy = (b.y < obstacle.y) ? -Math.abs(b.dy) : Math.abs(b.dy);
                    createParticles(b.x, b.y, "#ff0", 10); 
                    shake(5); 
                    SFX.triangle();
                }
                
                // ПРОИГРЫШ (Мяч улетел за левый край)
                if(b.x < -20) { 
                    if(balls.length > 1) {
                        balls.splice(i, 1); // Удаляем один из мячей (если их много)
                    } else { 
                        // ПРОВЕРКА РЕКОРДОВ ПРИ ГЕЙМОВЕРЕ
                        if (trajOn) {
                            if (argusScore > argusBest) {
                                argusBest = argusScore;
                                localStorage.setItem('rv_argus_best', argusBest);
                                document.getElementById('argus-best').innerText = argusBest;
                            }
                        } else {
                            if (score > best) {
                                best = score;
                                localStorage.setItem('rv_best', best);
                                bestEl.innerText = best;
                            }
                        }
                        isGameOver = true; 
                        SFX.damage(); 
                        forceResetUI(); 
                    } 
                }
            });

            // Отрисовка ракетки игрока
            ctx.fillStyle = trajOn ? "#a0f" : ((bTimer > 0) ? bFill.style.backgroundColor : '#0f0');
            ctx.shadowBlur = 15; 
            ctx.shadowColor = ctx.fillStyle; 
            ctx.fillRect(15, pY, 12, pH); 
            ctx.shadowBlur = 0;

            requestAnimationFrame(update);
        }

        // Запуск цикла
        update();
    </script>
</body>
</html>
